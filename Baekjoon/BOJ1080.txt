왜 그리디인가? 왜 최적해인가?

1. 알고리즘 정리
matA, matB를 문제에서의 행렬 A, B라고 하겠습니다. A와 B의 row, col 크기는 3이상이라고 하겠습니다.
(row, col 중 하나가 3보다 작다면, 변환을 할 수 없으므로 성분이 모두 같거나 하나라도 다른 경우만 고려하면 됩니다.)
boolean[][] check 배열을 하나 만들어서, check[i][j] = matA[i][j] != matB[i][j] 라고 하겠습니다.
뒤집을 3 by 3 부분행렬을, 가장 맨 왼쪽 위의 인덱스로 나타내겠습니다.
즉 flip(rowIdx, colIdx) 라는 것은, check[rowIdx + i][colIdx + j] 를 모두 뒤집는 함수입니다. (i, j = 0, 1, 2)
check 배열을 왼쪽 위부터 순회하면서 check[i][j]가 true이면 flip(i, j)를 합니다.
즉
for (int i = 0; i < row - 2; i++) {
  for (int j = 0; j < col - 2; j++) {
    if (check[i][j]) {
      flip(i, j);
    }
  }
}
입니다.

이 과정을 모두 거쳤을 때 check[][] 배열은 두 가지 상태가 됩니다.
1) 0 <= i < row - 2 && 0 <= j < col - 2 이외의 부분이 모두 false
2) 이외의 부분에 true가 적어도 하나 있음.

1)의 경우에는 A에서 B로의 전환이 성공한 경우로, flip이 호출된 횟수를 세서 출력하면 됩니다.
2)의 경우에는 A에서 B로의 전환이 실패한 경우입니다.

2. 두 가지 의문점
1) 1-1)에서, 이것이 진짜 최적해일까?
2) 1-2)에서, 다시 잘 뒤집으면 check배열 성분이 모두 false가 될 수도 있지 않을까?

Lemma1) G를 flip 함수들의 집합이라고 하면
G의 원소 g1, g2에 대해 g1g2 = g2g1, g1g1 = identity.(항등함수)
pf) 모든 i, j에 대해 (g1g2A)[i][j] = (g2g1A)[i][j]임을 체크하면 됩니다.
(i, j)는 g1의 flip 영역에만 속하던지, g2의 flip 영역에만 속하던지, 둘 다 속하던지, 둘 다 속하지 않던지, 네 가지 경우입니다.
각각의 경우를 적용하면 쉽게 확인할 수 있습니다.
g1g1 = identity는 같은 걸 두 번 뒤집었으니 원래대로 됩니다.

Lemma2) f를 flip을 유한번 적용하는 함수라고 한다면
f(A)는 0 <= i < row - 2, 0 <= j < col - 2 의 원소만으로 결정된다.(그 외의 원소는 자동으로 결정됨)
pf) 만일 f와 g가 flip을 유한번 적용하는 함수인데,
f(A)[i][j] = g(A)[]